---
title: "QualiCluster"
author: "Pietro Riva, Federico Maccianti"
date: "2025-12-30"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Working set up

```{r}
rm(list=ls())
setwd("C:/Users/4erre/Documents/PERSONALE/SCUOLA/A.A._2025-2026/Statistica_computazionale/Progetto/formula1")
options(warn = -1) 

library(tidyverse)
library(ggplot2)
library(dplyr)
library(RColorBrewer)
library(scales)
library(ggcorrplot)
library(mclust)
library(caret)
library(factoextra)
library(GGally)
library(Rmixmod)

```

# F1 : Telemetrie qualifiche

Il seguente studio si pone l'obiettivo di individuare dei possibili stili di guida attraverso il clustering model based.

## Esplorazione del dataset

Si va ora ad esplorare il dataset per :

- Effettuare una prima parte di data cleaning;
- Capire quali variabili possano essere indicative per individuare uno **stile di guida** per ciascun pilota;

### Analisi logica variabili

```{r}
tel <- readRDS("data/dataset_completo_best_tel.rds")
head(tel)
tel <- as_tibble(tel)


tel %>% group_by(GP,pilota) %>% summarize(n())
```

```{r}
str(tel)
```
```{r}
tel$lap_time <- as.numeric(tel$lap_time)
```

Le variabili presenti per ciascuna telemetria sono :

-   GP, pilota : Identificativi gara e pilota
-   time : Tempo dal via [s]
-   distance : Distanza percorsa [m]
-   rel_distance : Distanza normalizzata [0-1]
-   rpm : Giri motore [rpm]
-   speed : Velocità [km/h]
-   gear : Marcia [1-8]
-   throttle : Acceleratore [0-100%]
-   brake : Freno [0/1]
-   drs : DRS attivo [0/1]
-   acc_x : G longitudinale (+ accel, - freno)
-   acc_y : G laterale (+ destra, - sinistra)/
-   acc_z : G verticale
-   x, y, z : Coordinate spaziali [m]

Anzi tutto per ricercare un potenziale stile di guida bisogna individuare, a partire da queste variabili grezze, quelle che sono, in primo luogo, concettualmente legate al concetto di stile di guida. Con questo si fa riferimento a variabili quali:

-   throttle : utilizzo dell'accelleratore (brusco,graduale,intervallato, ...)
-   acc_x : tipologie di frenate (prevalentemente brusche/secche, più gestite, ...)
-   acc_y : tipologia di guida (accellerazioni in generale molto polarizzate potrebbero indicare una guida molto nervosa per esempio ...)

Le variabili posizionali

-   time
-   rel_distance
-   x, y, z

possono tornare utili per dare un riferimento alle rilevazioni.

Di seguito alcune analisi grafiche per verificare che queste variabili siano distinte, almeno in parte, da pilota a pilota.

```{r}
tel.ex <- tel %>% filter(GP == "United States Grand Prix" & (pilota == "VER" |pilota == "LEC"|pilota== "NOR"))
colori_team <- c("VER" = "#0600EF", "LEC" = "#EF1A2D", "NOR" = "#FF8700")



tel_g <- tel.ex %>%
  select(rel_distance, pilota, acc_y, acc_x) %>%
  pivot_longer(cols = c(acc_y, acc_x), 
               names_to = "variabile", 
               values_to = "valore") %>%
  mutate(variabile = factor(variabile, 
                            levels = c("acc_y", "acc_x"),
                            labels = c(" Accelerazione Laterale (g)", " Accelerazione Longitudinale (g)")))


pp <- ggplot(tel_g, aes(x = rel_distance, y = valore, color = pilota)) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray70", linewidth = 0.4) +
  geom_line(size = 0.6, alpha = 0.8) +
  facet_grid(variabile ~ ., scales = "free_y", switch = "y") + 
  scale_color_manual(values = colori_team) +
  theme_minimal(base_size = 12) +
  labs(
    x = "Distanza Relativa",
    y = NULL,
    color = "Pilota"
  ) +
  theme(
    strip.placement = "outside", 
    strip.text.y = element_text(face = "bold", size = 7),
    strip.background = element_rect(fill = "gray96", color = NA),
    legend.position = "top",
    panel.spacing = unit(1.2, "lines"),
    panel.grid.minor = element_blank(),
    plot.title = element_text(face = "bold", size = 16, margin = margin(b = 5)),
    plot.subtitle = element_text(size = 11, color = "gray30", margin = margin(b = 15))
  )

print(pp)


#ggsave("tel_ex1.pdf", pp, width = 7, height = 5, device = cairo_pdf)
```

### Data cleaning 

```{r}
summary(tel)
```
Notando che il massimo che assume la variabile *throttle* è 104 si riporta tutto sulla scala originaria tenendo come massimo 100

```{r}
tel$throttle <- ifelse(tel$throttle > 100, 100, tel$throttle)
```

Inoltre sono presenti alcune osservazioni `NA`. Analizzando il dataset originale in corrisondenza degli `NA` si nota come siano costanti le distanze e molti record pari a zero di conseguenza si presuppone che i sensori di telemetria abbiano avuto un'avaria si decide quindi di eliminare i dati relativi al GP di Miami di Russell.

```{r}
tel[which(is.na(tel$rel_distance)),]


tel <- tel %>% filter(pilota != "RUS" & GP != "Miami Grand Prix")
```

Un ultimo accorgimento riguarda la variabile *laptime*. Essa infatti è pari a `None` per i piloti Tsunoda, Bearman e Hadjar rispettivamente nei GP Emilia Romagna, Australian e Usa a causa del fatto che non hanno terminato il giro di qualifica quindi non c'è un tempo del giro, ma comunque si è registrata la telemetria. Al fine di eliminare rumore nell'analisi si rimuovono queste osservazioni.

Di seguito una rappresentazione visiva di quanto è stato appena osservato.

```{r}
tel.ex <- tel %>% filter(GP == "Emilia Romagna Grand Prix" & (pilota == "ANT" |pilota == "HAM"|pilota== "TSU"))
colori_team <- c("ANT" = "#0600EF", "HAM" = "#EF1A2D", "TSU" = "#FDD900")



tel_g <- tel.ex %>%
  select(rel_distance, pilota, acc_y, acc_x) %>%
  pivot_longer(cols = c(acc_y, acc_x), 
               names_to = "variabile", 
               values_to = "valore") %>%
  mutate(variabile = factor(variabile, 
                            levels = c("acc_y", "acc_x"),
                            labels = c(" Accelerazione Laterale (g)", " Accelerazione Longitudinale (g)")))


pp <- ggplot(tel_g
             , aes(x = rel_distance, y = valore, color = pilota)) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray70", linewidth = 0.4) +
  geom_line(size = 0.6, alpha = 0.8) +
  facet_grid(variabile ~ ., scales = "free_y", switch = "y") + 
  scale_color_manual(values = colori_team) +
  theme_minimal(base_size = 12) +
  labs(
    x = "Distanza Relativa",
    y = NULL,
    color = "Pilota"
  ) +
  theme(
    strip.placement = "outside", 
    strip.text.y = element_text(face = "bold", size = 7),
    strip.background = element_rect(fill = "gray96", color = NA),
    legend.position = "top",
    panel.spacing = unit(1.2, "lines"),
    panel.grid.minor = element_blank(),
    plot.title = element_text(face = "bold", size = 16, margin = margin(b = 5)),
    plot.subtitle = element_text(size = 11, color = "gray30", margin = margin(b = 15))
  )

print(pp)


#ggsave("tel_ex2.pdf", pp, width = 7, height = 5, device = cairo_pdf)
```

```{r}
tel %>% 
  group_by(GP, pilota) %>% 
  filter(is.na(lap_time)) %>% 
  summarize(n = n(), .groups = "drop")

tel <- tel %>% filter(!is.na(lap_time))

```

Si procede con la verifica che i dati siano coerenti con il regolamento *FIA* che prevede l'esclusione del pilota se il suo tempo supera il 107% del tempo minimo.

```{r}
tel %>% group_by(GP) %>% filter(lap_time > 1.07*min(lap_time))
```


```{r}
tel.guida_summary <- tel.guida_summary %>% filter(!(pilota=="STR" & GP=="Dutch Grand Prix"))
```

Visto che Nel GP di Las vegas la pista era bagnata nella Q1 e successivamente verso la fine è andata ad asciugarsi per la struttura del dataset visto che sono stati presi i migliori tempi per ogni pilota, dal filtraggio si evince che i piloti usciti in Q1 abbiano un tempo che non rientra nella regola quindi non si escludono dal dataset, cosa che per STR nel GP di Olanda non si può evitare essendo che ha avuto un incidente, e di conseguenza il tempo migliore risulta quello di un giro di riscaldamento.

## Feature engineering

Lo studio si pone di individuare stili di guida generali, non specifici di un circuito. Affinchè circuiti con molti rettilinei e circuiti con molte curve e nervosi siano conforntabili, si riscalano le accellerazioni, sia frontali che laterali, su un scala standard $[-1,1]$

```{r}
tel.guida <- tel %>%  
                group_by(GP,pilota) %>% 
                  mutate(
                   dec_x = if_else(acc_x < 0, abs(acc_x), 0),
                   acc_x = if_else(acc_x > 0, acc_x, 0)) %>% 
                      ungroup()

```

Si creano le seguenti variabili:

-   **lag1**
-   **lag3**
-   **lag5**

Per calcolare la variazione percentuale delle variabili *throttle*,*acc_x*,*acc_y*,*dec_x* che da un indicazione della magnitudo delle variazioni durante il giro.

```{r}
tel.guida <- tel.guida %>%
  
  select(GP,pilota,throttle,acc_x,acc_y,dec_x,rel_distance) %>% 
  
  arrange(GP,pilota,rel_distance) %>%
  
  group_by(GP,pilota) %>%
  
  mutate(
    across(
      c(throttle, acc_x, acc_y,dec_x),
      list(
        
      lag1 = ~round(
  ifelse(
    lag(.x, 1) == 0 & .x == 0,
    0,
    ifelse(
      lag(.x, 1) == 0,
          (.x-0.01)/0.01,
           (.x - lag(.x, 1)) / lag(.x, 1))
  ),
  4
),

lag3 = ~round(
  ifelse(
    lag(.x, 3) == 0 & .x == 0,
    0,
    ifelse(
      lag(.x, 3) == 0,
          (.x-0.01)/0.01,
           (.x - lag(.x, 3)) / lag(.x, 3))
  ),
  4
),

lag5 = ~round(
  ifelse(
    lag(.x, 5) == 0 & .x == 0,
    0,
    ifelse(
      lag(.x, 5) == 0,
          (.x-0.01)/0.01,
           (.x - lag(.x, 5)) / lag(.x, 5))
  ),
  4
)

      ),
      .names = "{.col}_{.fn}"
    )
  )  %>% 
  ungroup() %>% 
  select(-rel_distance)
```

Si raccolgono ora le prime statistiche riassuntive delle variabili per valutare in che modo si possano definire delle variabili associate a un potenziale stile di guida, in particolare :

Per le variabili *throttle* ,*acc_x*, *acc_y*

-   Media;
-   Deviazione standard;

```{r}
tel.guida_summary <- tel.guida %>% 
  group_by(GP, pilota) %>%
  {
    lag_cols <- names(.) %>% .[str_detect(., "lag")]
    
    summarise(.,
      across(
        c(throttle, acc_x, acc_y,dec_x), 
        list(
          mean = ~round(mean(.x, na.rm = TRUE), 4),
          sd = ~round(sd(.x, na.rm = TRUE), 4)
        ),
        .names = "{.col}_{.fn}"
      ),
    
      across(
        all_of(lag_cols),
        ~round(mean(.x[.x > 0], na.rm = TRUE), 4),
        .names = "{.col}_mean_pos"
      ),
      
      across(
        all_of(lag_cols),
        ~round(mean(.x[.x <= 0], na.rm = TRUE), 4),
        .names = "{.col}_mean_neg"
      ),
      
      across(
        all_of(lag_cols),
        ~round(sd(.x[.x > 0], na.rm = TRUE), 4),
        .names = "{.col}_sd_pos"
      ),
      
      across(
        all_of(lag_cols),
        ~round(sd(.x[.x <= 0], na.rm = TRUE), 4),
        .names = "{.col}_sd_neg"
      ),
      
      .groups = "drop"
    )
  }

tel2 <- tel %>% 
          group_by(GP,pilota) %>% 
              summarize(laptime=max(lap_time),strategy=(max(strategy)),gomma=(max(gomma)),.groups = "drop") 

tel.guida_summary$laptime <- as.numeric(tel2$laptime)
tel.guida_summary$strategy <- tel2$strategy
tel.guida_summary$gomma <- tel2$gomma

```





Creazione indice di variabile



```{r}
sd_cols <-tel.guida_summary %>% names(.) %>% .[str_detect(., "sd")]
mean_cols <-tel.guida_summary %>%  names(.) %>% .[str_detect(., "mean")]

tel.guida_summary.idx <- tel.guida_summary[sd_cols] / tel.guida_summary[mean_cols]

names(tel.guida_summary.idx) <- str_replace(names(tel.guida_summary.idx), "sd", "sd_stand")

tel.guida_summary.idx$GP <- tel.guida_summary$GP                                          

tel.guida_summary.idx$pilota <- tel.guida_summary$pilota                         
   
                            
                            
```











### PCA

Si valutano anzitutto le correlazioni tra le variabili per evitare problemi di multicollinearità.

```{r}

tel.guida_summary <- tel.guida_summary.idx %>% mutate(across(where(is.numeric),~rescale(.,to=c(0,1))))



corr <- round(cor(tel.guida_summary.idx %>% select(where(is.numeric))),4)

variabili_dipendenti <- findCorrelation(corr, cutoff = 0.9, names = TRUE, exact = T,verbose = T)

 print(variabili_dipendenti)
```

Filtraggio per variabili significative e normalizzare per gara

```{r}

tel.pca <- tel.guida_summary %>% select(-all_of(variabili_dipendenti))
```

*throttle_mean* :  l'intensità di accelerazionevalore alto stile "aggressivo" basso stile "assertivo" docile sull'acceleratore


*acc_x_mean*    : l'intensità di accelerazione in termini di forza g per ogni pilota un valore alto 


```{r}
PCA <- princomp(tel.pca %>%
                  select(where(is.numeric)),cor=T)

fviz_screeplot(PCA,choice= "variance")



summary(PCA)
print(PCA$loadings,cutoff = 0)
tel.comp <- as_tibble(PCA$scores[,c(1:6)])
```


Vediamo quali sono le variabili che decrivono le prime quattro componenti.

```{r}
for (i in 1:6){
 p <- fviz_contrib(PCA, choice = "var", axes = i, top = 15)
 print(p)
 }
```
Dai precedenti risultati si possono definire le componenti nel seguente modo

- *Comp1* : riguarda la componente longitudinale della guida, quindi accellerazione e decelerazione frontale. 

Comp 2 : intensità della forza g in curva

Comp 3 : intensità di utilizzo dell'acceleratore per ogni pilota 



Si nota come la `PCA` abbia evidenziato nella prima componente le variabili con più peso riguardano l'accelerazione longitudinale e la variazione dell' accelerazioni l'ampia variazione di queste variabili potrebbe assimilarsi in una versione di guida più dinamica e aggressiva per quanto riguarda la seconda componente è l'accelerazione laterale insieme alle decelerazioni a fornire contributo, quindi per quanto riguarda lo stile di guida potrebbe riguardare dei piloti che entrano ed escono molto forti dalle curve molto aggressivi in curva. Per la terza componente invece dominano le variabili di accelerazione longitudinale insieme alle variabili riguardanti la pressione del pedale di accelerazione, in particolare potrebbero rappresentare il momento prima delle frenate/
Per la quarta componente invece predomina la pressione del piede sull'acceleratore, rappresentando come ogni pilota gestisca il pedale Riguardo alla quinta componente ci sono variabili rappresentanti l'uscita da una curva Per la sesta componente ci sono variabili rappresentanti l'entrata in una curva



## Clustering

```{r}
clust <- Mclust(tel.comp,G=4)
summary(clust)
plot(clust, what="classification")
plot(clust, what="uncertainty")
plot(clust, what = "BIC", legendArgs = list(x = "topleft"))
clust$BIC
```





```{r}
clust <- Mclust(tel.comp)
summary(clust)
plot(clust, what="classification")
plot(clust, what="uncertainty")
plot(clust, what = "BIC", legendArgs = list(x = "topleft"))
clust$BIC
```





```{r}
comp.class <- unlist ( clust$classification )

tel.comp.labels <- tel.comp
tel.comp.labels["class"] <- clust$classification
tel.comp.labels$pilota <- tel.pca$pilota
tel.comp.labels$GP <- tel.pca$GP

tel.comp.labels$fill_pilota <- ifelse(tel.comp.labels$pilota %in% c("VER","HAM","BEA"),tel.comp.labels$pilota,"")

ggplot(tel.comp.labels, aes(x = Comp.2, y = Comp.4)) +
  
  geom_point(aes(color = as.factor(class)), size = 3) + 
  
  geom_text(aes(label = fill_pilota), vjust = -1, size = 3, check_overlap = FALSE) + 
  
  scale_color_brewer(palette = "Set1") +
  
  theme_minimal() +
  labs(title = "Plot Comp.2 vs Comp.4",
       color = "Classe")

ggplot(tel.comp.labels, aes(x = Comp.3, y = Comp.4)) +
  geom_point(aes(color = as.factor(class)), size = 3) + 
  geom_text(aes(label = pilota), vjust = -1, size = 3, check_overlap = FALSE) + 
  scale_color_brewer(palette = "Set1") +
  theme_minimal() +
  labs(title = "Plot Comp.3 vs Comp.4",
       color = "Classe") 


```

```{r}
summary <- tel.comp.labels %>%
  group_by(class) %>%
  summarize(
    across(where(is.numeric),
    list(
      mean = ~mean(.x, na.rm=T)
  )), .groups = "drop"
  )
summary2 <- tel.comp.labels %>%
  group_by(pilota,class) %>%
  summarize(
    across(where(is.numeric),
    list(
      mean = ~mean(.x, na.rm=T)
  )),n() ,.groups = "drop"
  )

table(tel.comp.labels$pilota,tel.comp.labels$class)

```

```{r}
tel.lap <- tel %>% group_by(GP,pilota) %>% summarize(laptime=max(lap_time))

tel.clust$laptime <- tel.lap$laptime

tel.clust <- tel.clust %>% arrange(laptime,GP,pilota,)
```


```{r}
listmod=c("Gaussian_pk_L_I","Gaussian_pk_Lk_I","Gaussian_pk_L_B","Gaussian_pk_Lk_B","Gaussian_pk_L_Bk",
          "Gaussian_pk_Lk_Bk","Gaussian_pk_L_C","Gaussian_pk_Lk_C","Gaussian_pk_L_D_Ak_D","Gaussian_pk_Lk_D_Ak_D",
          "Gaussian_pk_L_Dk_A_Dk","Gaussian_pk_Lk_Dk_A_Dk","Gaussian_pk_L_Ck","Gaussian_pk_Lk_Ck")
tel.data <- tel.comp[,c(2,4)]
tel.comp.labels$class <- as.factor(tel.comp.labels$class)
tel.class <- unlist( tel.comp.labels[,7] )
str(tel.class)
str(tel.data)



res = mixmodLearn(tel.data[-test.set,], tel.class[-test.set], 
                  models=mixmodGaussianModel(listModels=listmod,equal.proportions=F),
                  criterion=c('CV','BIC'))
summary(res)

prediction <- mixmodPredict(data=tel.data[test.set,],classificationRule=res["bestResult"])

mean(as.integer(tel.class[test.set]) == prediction@partition)
```



