---
title: "QualiCluster"
author: "Pietro Riva, Federico Maccianti, Nicola Rapacioli"
date: "2025-12-30"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Working set up

```{r}
rm(list=ls())

library(tidyverse)
library(ggplot2)
library(dplyr)
library(RColorBrewer)
library(scales)
library(ggcorrplot)
library(mclust)
library(caret)
library(factoextra)
library(GGally)
library(Rmixmod)
library(dotenv)
library(flexmix)

options(warn = -1) 

load_dot_env()
setwd(Sys.getenv("WORK_DIR"))

data_path <- Sys.getenv("DATA")
```

# F1 : Telemetrie qualifiche

Il seguente studio si pone l'obiettivo di individuare dei possibili stili di guida attraverso il clustering model based.

## Esplorazione del dataset

Si va ora ad esplorare il dataset per :

-   Effettuare operazioni di data cleaning;
-   Capire quali variabili possano essere indicative per individuare uno **stile di guida** per ciascun pilota;

### Analisi logica variabili

```{r}
tel <- readRDS(data_path)
head(tel)
tel <- as_tibble(tel)


tel %>% group_by(GP,pilota) %>% summarize(n())
```

```{r}
str(tel)
```

```{r}
tel$lap_time <- as.numeric(tel$lap_time)
```

Le variabili presenti per ciascuna telemetria sono :

-   GP, pilota : Identificativi gara e pilota
-   time : Tempo dal via [s]
-   distance : Distanza percorsa [m]
-   rel_distance : Distanza normalizzata [0-1]
-   rpm : Giri motore [rpm]
-   speed : Velocità [km/h]
-   gear : Marcia [1-8]
-   throttle : Acceleratore [0-100%]
-   brake : Freno [0/1]
-   drs : DRS attivo [0/1]
-   acc_x : G longitudinale (+ accel, - freno)
-   acc_y : G laterale (+ destra, - sinistra)/
-   acc_z : G verticale
-   x, y, z : Coordinate spaziali [m]

Anzi tutto per ricercare un potenziale stile di guida bisogna individuare, a partire da queste variabili grezze, quelle che sono in primo luogo concettualmente legate al concetto di stile di guida. Con questo si fa riferimento a variabili quali:

-   throttle : utilizzo dell'accelleratore (brusco,graduale,intervallato, ...)
-   brake : utilizzo del freno
-   acc_x : tipologie di frenate (prevalentemente brusche/secche, più gestite, ...)
-   acc_y : tipologia di guida (accellerazioni in generale molto polarizzate potrebbero indicare una guida molto nervosa per esempio ...)
-   brake  ( variazione dell'utilizzo del freno nel tempo)
-   speed   (gestione della velocità nel tracciato, preferenza di aumenti progressivi oppure di aumenti                     repentini)


Le variabili posizionali

-   time
-   rel_distance
-   x, y, z

possono tornare utili per dare un riferimento alle rilevazioni.

Di seguito alcune analisi grafiche per verificare che queste variabili siano distinte, almeno in parte, da pilota a pilota.

```{r}
tel.ex <- tel %>% filter(GP == "United States Grand Prix" & (pilota == "VER" |pilota == "LEC"|pilota== "COL"|pilota=="BEA"))
colori_team <- c("VER" = "#0600EF", "LEC" = "#EF1A2D", "COL" = "#FF8700","BEA"="#000000")



tel_g <- tel.ex %>%
  select(rel_distance, pilota, acc_y, acc_x,speed,brake,throttle) %>%
  pivot_longer(cols = c(acc_y, acc_x,speed,throttle), 
               names_to = "variabile", 
               values_to = "valore") %>%
  mutate(variabile = factor(variabile, 
                            levels = c("acc_y", "acc_x","speed","throttle"),
                            labels = c(" Acc. lat (g)", " Acc. long g(0)", "Vel (km/s)","Acc. (%)" )))


pp <- ggplot(tel_g, aes(x = rel_distance, y = valore, color = pilota)) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray70", linewidth = 0.4) +
  geom_line(size = 0.6, alpha = 0.8) +
  facet_grid(variabile ~ ., scales = "free_y", switch = "y") + 
  scale_color_manual(values = colori_team) +
  theme_minimal(base_size = 12) +
  labs(
    x = "Distanza relativa",
    y = NULL,
    color = "Pilota"
  ) +
  theme(
    strip.placement = "outside", 
    strip.text.y = element_text(face = "bold", size = 7),
    strip.background = element_rect(fill = "gray96", color = NA),
    legend.position = "top",
    panel.spacing = unit(1.2, "lines"),
    panel.grid.minor = element_blank(),
    plot.title = element_text(face = "bold", size = 16, margin = margin(b = 5)),
    plot.subtitle = element_text(size = 11, color = "gray30", margin = margin(b = 15))
  )

print(pp)


#ggsave("tel_ex1.pdf", pp, width = 7, height = 5, device = cairo_pdf)
```

### Data cleaning

```{r}
summary(tel)
```

Notando che il massimo che assume la variabile *throttle* è 104 si riporta tutto sulla scala originaria tenendo come massimo 100

```{r}
tel$throttle <- ifelse(tel$throttle > 100, 100, tel$throttle)
```

Inoltre sono presenti alcune osservazioni `NA`. Analizzando il dataset originale in corrisondenza degli `NA` si nota come siano costanti le distanze e molti record pari a zero di conseguenza si presuppone che i sensori di telemetria abbiano avuto un'avaria si decide quindi di eliminare i dati relativi al GP di Miami di Russell.

```{r}
tel[which(is.na(tel$rel_distance)),]


tel <- tel %>% filter(pilota != "RUS" & GP != "Miami Grand Prix")
```

Un ultimo accorgimento riguarda la variabile *laptime*. Essa infatti è pari a `None` per i piloti Tsunoda, Bearman e Hadjar rispettivamente nei GP Emilia Romagna, Australian e Usa a causa del fatto che non hanno terminato il giro di qualifica quindi non c'è un tempo del giro, ma comunque si è registrata la telemetria. Al fine di eliminare rumore nell'analisi si rimuovono queste osservazioni.

Di seguito una rappresentazione visiva di quanto è stato appena osservato.

```{r}
tel.ex <- tel %>% filter(GP == "Australian Grand Prix" & (pilota == "BEA" |pilota == "HAM"|pilota== "TSU"))
colori_team <- c("BEA" = "#0600EF", "HAM" = "#EF1A2D", "TSU" = "#FDD900")



tel_g <- tel.ex %>%
  select(rel_distance, pilota, acc_y, acc_x) %>%
  pivot_longer(cols = c(acc_y, acc_x), 
               names_to = "variabile", 
               values_to = "valore") %>%
  mutate(variabile = factor(variabile, 
                            levels = c("acc_y", "acc_x"),
                            labels = c(" Accelerazione laterale (g)", " Accelerazione longitudinale (g)")))


pp <- ggplot(tel_g
             , aes(x = rel_distance, y = valore, color = pilota)) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "gray70", linewidth = 0.4) +
  geom_line(size = 0.6, alpha = 0.8) +
  facet_grid(variabile ~ ., scales = "free_y", switch = "y") + 
  scale_color_manual(values = colori_team) +
  theme_minimal(base_size = 12) +
  labs(
    x = "Distanza relativa",
    y = NULL,
    color = "Pilota"
  ) +
  theme(
    strip.placement = "outside", 
    strip.text.y = element_text(face = "bold", size = 7),
    strip.background = element_rect(fill = "gray96", color = NA),
    legend.position = "top",
    panel.spacing = unit(1.2, "lines"),
    panel.grid.minor = element_blank(),
    plot.title = element_text(face = "bold", size = 16, margin = margin(b = 5)),
    plot.subtitle = element_text(size = 11, color = "gray30", margin = margin(b = 15))
  )

print(pp)


#ggsave("tel_ex2.pdf", pp, width = 7, height = 5, device = cairo_pdf)
```

```{r}
tel %>% 
  group_by(GP, pilota) %>% 
  filter(is.na(lap_time)) %>% 
  summarize(n = n(), .groups = "drop")

tel <- tel %>% filter(!is.na(lap_time))

tel
```

Si procede con la verifica che i dati siano coerenti con il regolamento *FIA* che prevede l'esclusione del pilota se il suo tempo supera il 107% del tempo minimo.

```{r}
tel %>% group_by(GP) %>% filter(lap_time > 1.07*min(lap_time))
```

Nel GP di Las Vegas, durante la Q1 la pista era inizialmente bagnata, ma si è progressivamente asciugata nel corso delle qualifiche. Poiché il dataset considera per ogni pilota solo il miglior tempo registrato, i piloti eliminati in Q1 possono avere tempi che non rispecchiano la condizione tipica della sessione (cioè tempi influenzati dalla pista bagnata) e, di conseguenza, non vengono esclusi dal dataset. In contrasto, nel GP di Olanda, il pilota Strole ha avuto un incidente in Q1 e il suo miglior tempo disponibile risulta quindi quello di un giro di riscaldamento, che non rappresenta le prestazioni reali in qualifica.

```{r}
tel <- tel %>% filter(!(pilota=="STR" & GP=="Dutch Grand Prix"))
```

## Feature engineering

Si modificano/creano le seguenti variabili :

-   *acc_x* : accellerazioni longitudinali positive;
-   *dec_x* : accellerazioni longitudinali negative (in modulo);
-   *acc_y* : accellerazioni laterali in modulo. In questo modo si evitano distorsioni nelle statistiche causate dal segno, permettendo di analizzare l’intensità complessiva delle forze laterali indipendentemente dalla direzione della curva (destra o sinistra);

```{r}
tel.guida <- tel %>%  
                group_by(GP,pilota) %>% 
                  mutate(
                   dec_x = if_else(acc_x < 0, abs(acc_x), 0),
                   acc_x = if_else(acc_x > 0, acc_x, 0),
                   acc_y = abs(acc_y)) %>% 
                      ungroup()

```

Per calcolare la variazione percentuale delle variabili *throttle*,*acc_x*,*acc_y*,*dec_x* e *speed* e ottenere un indicazione della magnitudo delle variazioni durante il giro, si calcolano le seguenti variabili :

-   \*\*\_lag1\*\* : breve periodo;
-   \*\*\_lag5\*\* : medio perodo;

```{r}
tel.guida <- tel.guida %>%
  
  select(GP,pilota,throttle,acc_x,acc_y,dec_x,brake,speed,rel_distance) %>% 
  
  arrange(GP,pilota,rel_distance) %>%
  
  group_by(GP,pilota) %>%
  
  mutate(
    across(
      c(throttle, acc_x, acc_y,dec_x,speed),
      list(
        
      lag1 = ~round(
  ifelse(
    lag(.x, 1) == 0 & .x == 0,
    0,
    ifelse(
      lag(.x, 1) == 0,
          (.x-0.01)/0.01,
           (.x - lag(.x, 1)) / lag(.x, 1))
  ),
  4
),

lag5 = ~round(
  ifelse(
    lag(.x, 5) == 0 & .x == 0,
    0,
    ifelse(
      lag(.x, 5) == 0,
          (.x-0.01)/0.01,
           (.x - lag(.x, 5)) / lag(.x, 5))
  ),
  4
)

      ),
      .names = "{.col}_{.fn}"
    )
  )  %>%  
  ungroup() %>% 
  select(-rel_distance)
```

Si calcolano ora le prime statistiche riassuntive delle variabili per valutare in che modo si possano definire delle variabili associate a un potenziale stile di guida, in particolare :

Per le variabili *throttle* ,*acc_x*, *dec_x*, *acc_y* e \*\_lag\* (distintamente per variazioni positive e negative):

-   Media;
-   Deviazione standard;

```{r}
tel.guida_summary <- tel.guida %>% 
  group_by(GP, pilota) %>%
  {
    lag_cols <- names(.) %>% .[str_detect(., "lag")]
    
    summarise(.,
      across(
        c(throttle, acc_x, acc_y,dec_x,brake,speed), 
        list(
          mean = ~round(mean(.x, na.rm = TRUE), 4),
          sd = ~round(sd(.x, na.rm = TRUE), 4)
        ),
        .names = "{.col}_{.fn}"
      ),
    
      across(
        all_of(lag_cols),
        ~round(mean(.x[.x > 0], na.rm = TRUE), 4),
        .names = "{.col}_mean_pos"
      ),
      
      across(
        all_of(lag_cols),
        ~round(mean(.x[.x <= 0], na.rm = TRUE), 4),
        .names = "{.col}_mean_neg"
      ),
      
      across(
        all_of(lag_cols),
        ~round(sd(.x[.x > 0], na.rm = TRUE), 4),
        .names = "{.col}_sd_pos"
      ),
      
      across(
        all_of(lag_cols),
        ~round(sd(.x[.x <= 0], na.rm = TRUE), 4),
        .names = "{.col}_sd_neg"
      ),
      
      .groups = "drop"
    )
  }

tel2 <- tel %>% 
          group_by(GP,pilota) %>% 
              summarize(laptime=max(lap_time),strategy=(max(strategy)),gomma=(max(gomma)),.groups = "drop") 

tel.guida_summary$laptime <- as.numeric(tel2$laptime)
tel.guida_summary$strategy <- tel2$strategy
tel.guida_summary$gomma <- tel2$gomma

```

Il calcolo di queste statistiche ha l’obiettivo di ottenere degli indicatori che descrivano lo stile di guida dei piloti. Una volta calcolate la media e la deviazione standard delle variabili, è possibile combinare questi valori per ottenere il **coefficiente di variazione** (CV):

$$
\text{CV} =\dfrac{sd(x)}{mean(x)}
$$

che misura la variabilità relativa di una variabile rispetto alla sua media.

```{r}
sd_cols <-tel.guida_summary %>% names(.) %>% .[str_detect(., "sd")]
mean_cols <-tel.guida_summary %>%  names(.) %>% .[str_detect(., "mean")]

tel.guida_summary.idx <- tel.guida_summary[sd_cols] / tel.guida_summary[mean_cols]

names(tel.guida_summary.idx) <- str_replace(names(tel.guida_summary.idx), "sd", "sd_stand")

tel.guida_summary.idx$GP <- tel.guida_summary$GP                                          

tel.guida_summary.idx$pilota <- tel.guida_summary$pilota                         
```

### PCA

Per poter confrontare diversi circuiti (e.g forte presenza di rettilinei e curve veloci vs nervosi e tortuosi) si riscala per ciascun circuito il coefficiente di variazione in $[0,1]$.

```{r}
tel.guida_summary.idx <- tel.guida_summary.idx %>% mutate(across(where(is.numeric),~rescale(.,to=c(0,1))))
```

Si procede ora a valutare le correlazioni tra le variabili per evitare problemi di multicollinearità.

```{r}
corr <- round(cor(tel.guida_summary.idx %>% select(where(is.numeric))),4)

variabili_dipendenti <- findCorrelation(corr, cutoff = 0.9, names = TRUE, exact = T,verbose = T)

print(variabili_dipendenti)
```

Si filtra infine il dataset, andando ad utilizzare solamente le variabili non fortemente correlate.

```{r}
tel.pca <- tel.guida_summary.idx %>% select(-all_of(variabili_dipendenti))
```

Di seguito un'interpretazione delle variabili che verranno utilizzate per la PCA :

-   `throttle_sd_stand` : rappresenta un indicatore normalizzato della variabilità dell’input del pilota sul pedale dell’acceleratore. Valori più elevati sono associati a una maggiore modulazione del gas, mentre valori più bassi indicano un uso più stabile e costante.

-   `acc_x_sd_stand` : rappresenta un indicatore normalizzato della variabilità dell’accelerazione longitudinale positiva. Valori elevati indicano una modulazione più marcata della trazione in uscita di curva, mentre valori bassi suggeriscono una spinta più uniforme e progressiva.

-   `acc_y_sd_stand` : rappresenta un indicatore normalizzato della variabilità della decelerazione in fase di frenata. Valori più elevati riflettono una maggiore modulazione del freno, mentre valori più bassi sono associati a frenate più stabili e regolari.

-   `dec_x_sd_stand` : rappresenta un indicatore normalizzato della variabilità dell’accelerazione laterale in curva. Valori più elevati descrivono una percorrenza curva più dinamica e variabile, mentre valori più bassi indicano forze laterali più uniformi e costanti.

-   `brake_sd_stand`: rappresenta un indicatore normalizzato della variabilità dell’attivazione del freno. Valori elevati indicano un utilizzo del freno più intermittente o modulato, mentre valori bassi indicano un uso più stabile.

-   `speed_sd_stand`: rappresenta un indicatore normalizzato della variabilità della velocità. Valori elevati indicano variazioni di velocità più marcate, mentre valori bassi indicano velocità più costante lungo il giro.

-   `throttle_lag1_sd_stand_pos` : rappresenta un indicatore normalizzato della variabilità delle variazioni positive dell’input dell’acceleratore al lag di 1 istante temporale. Valori più elevati indicano aumenti del gas meno uniformi e maggiormente modulati, mentre valori più bassi suggeriscono incrementi più progressivi e regolari.

-   `throttle_lag5_sd_stand_pos` : rappresenta un indicatore normalizzato della variabilità delle variazioni positive dell’input dell’acceleratore osservate a un lag di 5 istanti temporali. Valori più elevati riflettono una modulazione del gas più dinamica nel medio periodo, mentre valori più bassi indicano aumenti dell’acceleratore più stabili e costanti.

-   `acc_x_lag1_sd_stand_pos` : rappresenta un indicatore normalizzato della variabilità delle variazioni positive dell’accelerazione longitudinale (trazione) al lag di 1 istante. Valori elevati descrivono una spinta in accelerazione meno uniforme, mentre valori bassi indicano una trazione più progressiva e lineare.

-   `acc_x_lag5_sd_stand_pos` : rappresenta un indicatore normalizzato della variabilità delle variazioni positive dell’accelerazione longitudinale al lag di 5 istanti. Valori elevati sono associati a una dinamica di accelerazione più variabile nel medio periodo, mentre valori bassi indicano una spinta più costante.

-   `acc_y_lag1_sd_stand_pos` :rappresenta un indicatore normalizzato della variabilità delle variazioni positive dell’accelerazione laterale al lag di 1 istante. Valori più elevati indicano cambiamenti laterali più dinamici in curva, mentre valori più bassi descrivono una percorrenza laterale più uniforme.

-   `acc_y_lag5_sd_stand_pos` : rappresenta un indicatore normalizzato della variabilità delle variazioni positive dell’accelerazione laterale al lag di 5 istanti. Valori elevati riflettono una maggiore eterogeneità delle forze laterali nel medio periodo, mentre valori bassi indicano una dinamica laterale più stabile.

-   `dec_x_lag1_sd_stand_pos` : rappresenta un indicatore normalizzato della variabilità delle variazioni positive della decelerazione (fase di frenata) al lag di 1 istante. Valori elevati indicano una modulazione del freno più irregolare, mentre valori bassi sono associati a frenate più uniformi e controllate.

-   `dec_x_lag5_sd_stand_pos` : rappresenta un indicatore normalizzato della variabilità delle variazioni positive della decelerazione al lag di 5 istanti. Valori più elevati suggeriscono una gestione del freno più dinamica nel medio periodo, mentre valori più bassi descrivono frenate più stabili e ripetibili.

-   `throttle_lag1_sd_stand_neg` : rappresenta un indicatore normalizzato della variabilità delle variazioni negative dell’input dell’acceleratore al lag di 1 istante. Valori più elevati descrivono rilasci del gas più irregolari e discontinui, mentre valori più bassi indicano riduzioni dell’acceleratore più progressive.

-    `speed_lag1_sd_stand_pos`: rappresenta un indicatore normalizzato della variabilità delle variazioni positive della velocità al lag di 1. Valori elevati indicano accelerazioni più irregolari, valori bassi accelerazioni più lineari.

-    `speed_lag5_sd_stand_pos`: rappresenta un indicatore normalizzato della variabilità delle variazioni positive della velocità al lag di 5. Valori elevati indicano accelerazioni più dinamiche nel medio periodo, valori bassi velocità più costante.

-   `acc_x_lag1_sd_stand_neg` : rappresenta un indicatore normalizzato della variabilità delle variazioni negative dell’accelerazione longitudinale al lag di 1 istante. Valori elevati suggeriscono riduzioni della spinta più variabili nel tempo, mentre valori bassi indicano una diminuzione più uniforme.

-   `acc_x_lag5_sd_stand_neg` : rappresenta un indicatore normalizzato della variabilità delle variazioni negative dell’accelerazione longitudinale al lag di 5 istanti. Valori elevati riflettono una riduzione della trazione più dinamica nel medio periodo, mentre valori bassi descrivono un calo di accelerazione più costante.

-   `acc_y_lag1_sd_stand_neg` : rappresenta un indicatore normalizzato della variabilità delle variazioni negative dell’accelerazione laterale al lag di 1 istante. Valori elevati descrivono cambiamenti laterali verso la riduzione della forza in curva più irregolari, mentre valori bassi indicano una dinamica laterale più graduale.

-   `acc_y_lag5_sd_stand_neg` : rappresenta un indicatore normalizzato della variabilità delle variazioni negative dell’accelerazione laterale al lag di 5 istanti. Valori elevati sono associati a una maggiore variabilità della riduzione delle forze laterali nel medio periodo, mentre valori bassi indicano variazioni più uniformi.

-   `dec_x_lag1_sd_stand_neg` : rappresenta un indicatore normalizzato della variabilità delle variazioni negative della decelerazione al lag di 1 istante. Valori più elevati indicano una riduzione meno uniforme dell’intensità frenante, mentre valori più bassi suggeriscono una modulazione del freno più stabile.

-    `speed_lag1_sd_stand_neg` : rappresenta un indicatore normalizzato della variabilità delle variazioni negative della velocità al lag di 1. Valori elevati indicano decelerazioni più irregolari, valori bassi più lineari.

-    `speed_lag5_sd_stand_neg` : rappresenta un indicatore normalizzato della variabilità delle variazioni negative della velocità al lag di 5. Valori elevati indicano decelerazioni più dinamiche nel medio periodo, valori bassi decelerazioni più costanti.

Nota metodologica:

> L’impiego del coefficiente di variazione riduce l’influenza del setup della vettura, rendendo confrontabili tra loro variabili che, in valore assoluto, dipendono dalle regolazioni meccaniche e aerodinamiche.

```{r}
PCA <- princomp(tel.pca %>%
                  select(where(is.numeric)),cor=T)


cumulative <- as_tibble(get_eigenvalue(PCA)$cumulative.variance.percent)

cumulative$Componenti <- 1:24

p <- ggplot(cumulative, aes(x=Componenti,y=value))+
  geom_bar(stat="identity",aes(fill = value))+
  scale_fill_fermenter(palette = "Set2")+
  geom_label(aes(label=round(value,2)),stat="identity")+
  labs(title= "Cumulative variance",
       y="Proporzione")+
  theme_minimal()
print(p)
#ggsave("tel_pca.pdf", p, width = 7, height = 5, device = cairo_pdf)




summary(PCA)
print(PCA$loadings,cutoff = 0)
```

```{r}
for (i in 1:5){
 p <- fviz_contrib(PCA, choice = "var", axes = i, top = 15)
 print(p)
 }
```

**RIFARE!!**


Dai precedenti risultati si possono definire le componenti nel seguente modo :

-   `Comp.1` : Dinamica longitudinale complessiva e variabilità dell'utilizzo del gas. Descrive l’intensità e l’instabilità delle accelerazioni e decelerazioni longitudinali, in relazione alle variazioni del comando throttle.

    -   **Score elevati**: indicano una dinamica longitudinale più irruenta, con maggiori variazioni di accelerazione e frenata e una modulazione più marcata del gas. Possono riflettere uno stile di guida aggressivo.

    -   **Score bassi**: indicano accelerazioni e frenate più stabili e regolari, con un uso dell’acceleratore più costante. Sono coerenti con uno stile di guida più fluido.

-   `Comp.2` : Dinamica laterale globale. Rappresenta la variabilità associata all’accelerazione laterale e quindi ai trasferimenti di carico in curva.

    -   **Score elevati**: indicano una dinamica laterale più intensa e variabile, associata a percorrenze in curva impegnative e a trasferimenti di carico trasversali marcati.

    -   **Score bassi**: indicano una dinamica laterale più contenuta e uniforme, tipica di tratti più lineari o di una guida più stabile.

-   `Comp.3` : Reattività del sistema agli input crescenti Cattura la rapidità e l’ampiezza delle variazioni positive dell'uso dell'accelleratore e delle corrispondenti risposte dinamiche del veicolo.

    -   **Score elevati**: descrivono una fase di accelerazione decisa (es. uscita curva), con variazioni rapide e consistenti.

    -   **Score bassi**: indicano input più graduali e una dinamica più progressiva.

-   `Comp.4` : Dinamica in frenata e in ingresso curva.È associata alle variazioni di decelerazione e alla componente laterale che accompagna la frenata.

    -   **Score elevati**: indicano frenate intense e variabili, spesso in presenza di componente laterale significativa, caratterizzanti una fase di staccata e ingresso curva molto aggressiva e decisa.

    -   **Score bassi**: indicano frenate più progressive e stabili, con minori variazioni laterali, suggerendo un ingresso curva più controllato.

-   `Comp.5`: Risposta della vettura a variazioni di carico. Riflette la sensibilità della dinamica laterale e longitudinale a variazioni progressive degli input, potenzialmente influenzata dal setup meccanico e aerodinamico.

    -   **Score elevati** : indicano un veicolo e un sistema pilota–vettura molto reattivi alle variazioni di carico, con una dinamica che risponde in modo marcato anche a cambiamenti progressivi. Valori alti possono riflettere un setup più rigido o una configurazione aerodinamica che amplifica la reattività della vettura.
    -   **Score bassi** : indicano una risposta più smorzata e filtrata, coerente con un comportamento più stabile e prevedibile. Possono essere associati a setup più morbidi o a regolazioni che riducono la sensibilità alle variazioni di carico, privilegiando la stabilità rispetto alla reattività.

## Clustering

Si filtra per le prime cinque componenti ottenute.

```{r}
tel.comp <- as_tibble(PCA$scores[,c(1:5)])
```

Si procede ora a effettuare un primo clustering

```{r}
clust <- Mclust(tel.comp)
summary(clust)
plot(clust, what="classification")
plot(clust, what="uncertainty")
plot(clust, what = "BIC", legendArgs = list(x = "bottomleft"))
clust$BIC
```

Metriche di valutazione

```{r}
cat("KL distance \n")
KL <- clust$icl - clust$bic; KL

cat("Incertezza attesa \n")
mean(clust$uncertainty)
```

Il modello trovato è un VEE 9 con BIC pari a -7949.208 il con KL pari a 50

Notando come le componenti 1 e 2 siano le più discriminanti per il clustering, si prova quindi ad applicare il Model Base Clustering solo sulle prime due componenti 

```{r}
tel.comp <- tel.comp %>% select(Comp.2,Comp.1)


clust <- Mclust(tel.comp)
summary(clust)
plot(clust, what="classification")
plot(clust, what="uncertainty")
plot(clust, what = "BIC", legendArgs = list(x = "bottomleft"))
clust$BIC


```
Il modello trovato è un EEV 5 con BIC pari a -3752.150, molto superiore rispetto al modello precedente, e graficamente più distinti i gruppi tra di loro con KL circa pari a 100 di conseguenza si predilige il seguente modello al precedente.



```{r}
comp.class <- unlist ( clust$classification )
tel.comp.labels <- tel.comp
tel.comp.labels["class"] <- clust$classification
tel.comp.labels$pilota <- tel.pca$pilota
tel.comp.labels$GP <- tel.pca$GP

tel.comp.labels$laptime <- tel2$laptime

tel.comp.labels <- tel.comp.labels %>% arrange(laptime,GP,pilota,)
```


------------------------------------------------------------------------


### Interpretazione dei risultati

```{r}
unique_GP <- unique(tel.comp.labels$GP)

x_lim <- range(tel.comp.labels$Comp.2, na.rm = TRUE)
y_lim <- range(tel.comp.labels$Comp.1, na.rm = TRUE)



for (gp in unique_GP) {
  
   p <- ggplot(tel.comp.labels %>% filter(GP == gp), aes(x = Comp.2, y = Comp.1)) +
  geom_text(aes(label = pilota,colour  = as.factor(class)), vjust = -1, size = 3, check_overlap = F) + 
  scale_color_brewer(palette = "Set1") +
  coord_cartesian(xlim = x_lim, ylim = y_lim)+
  theme_minimal() +
  labs(title = paste0("Plot Comp.2 vs Comp.1 ", gp),
       fill = "Classe") 
   print(p)
}


p <- ggplot(tel.comp.labels, aes(x = Comp.2, y = Comp.1)) +
    geom_point(aes(colour = as.factor(class)), alpha = 0) + 
    geom_text(aes(label = GP, colour = as.factor(class)), 
            vjust = -1, size = 3, check_overlap = T,show.legend = F) + 
  scale_color_brewer(palette = "Set1", type = "qual") +
  coord_cartesian(xlim = c(-5,5), ylim = c(-7,7)) +
  labs(title = paste0("Plot Comp.2 vs Comp.1 ", gp),
       colour = "Classe") +
  guides(colour = guide_legend(override.aes = list(alpha = 1, size = 5, shape = 19)))

print(p)

```

La clusterizzazione tramite Model Based clustering, ha evidenziato due cluster: - il *primo* nel quale i piloti hanno un atteggiamento più progressivo,graduale e *stabile*, nella guida. - il *secondo* nel quale si ha un atteggiamento più *instabile* e aggressivo

- Il *primo* cluster comprende prevalentemente Gran Premi con piste caratterizzate da numerose curve a medio-bassa velocità, nei quali i piloti mostrano una gestione longitudinale relativamente costante e una maggiore variabilità della dinamica laterale.

- Il *secondo* cluster raccoglie Gran Premi associati a circuiti caratterizzati da curve veloci e sequenze fluide, in cui le accelerazioni e decelerazioni longitudinali risultano più graduali.

- Il *terzo* cluster include Gran Premi tipicamente legati a tracciati con curve a medio-bassa velocità, nei quali la variabilità longitudinale è elevata a fronte di una minore variabilità laterale.

- Il *quarto* cluster rappresenta una configurazione intermedia, comprendente circuiti con caratteristiche miste.

- Il *quinto* cluster comprende Gran Premi associati a circuiti stop-and-go, con molte curve lente e pochi rettilinei, nei quali si osserva una gestione più irregolare dell’accelerazione longitudinale.


Esempi chiari, sono il gp di `Las Vegas` per quanto riguarda lo stile stabile sempre per le condizioni atmosferiche, invece si può osservare nella pista di `Monaco` come lo stile sia per lo più instabile e aggressivo, dovuto per l'appunto alla configurazione del tracciato.

```{r}
summary <- tel.comp.labels %>%
  group_by(class) %>%
  summarize(
    across(where(is.numeric),
    list(
      mean = ~mean(.x, na.rm=T)
  )), .groups = "drop"
  )
summary2 <- tel.comp.labels %>%
  group_by(pilota,GP,class) %>%
  summarize(
    across(where(is.numeric),
    list(
      mean = ~mean(.x, na.rm=T)
  )),n() ,.groups = "drop"
  )

table(tel.comp.labels$GP,tel.comp.labels$class)

```

```{r}
print(summary)
print(summary2)
```

## Classificazione

```{r}
listmod=c("Gaussian_pk_L_I","Gaussian_pk_Lk_I","Gaussian_pk_L_B","Gaussian_pk_Lk_B","Gaussian_pk_L_Bk",
          "Gaussian_pk_Lk_Bk","Gaussian_pk_L_C","Gaussian_pk_Lk_C","Gaussian_pk_L_D_Ak_D","Gaussian_pk_Lk_D_Ak_D",
          "Gaussian_pk_L_Dk_A_Dk","Gaussian_pk_Lk_Dk_A_Dk","Gaussian_pk_L_Ck","Gaussian_pk_Lk_Ck")
tel.data <- tel.comp[,c(1,2)]
tel.comp.labels$class <- as.factor(tel.comp.labels$class)
tel.class <- unlist( tel.comp.labels[,3] )
str(tel.class)
str(tel.data)


set.seed(789)
vec <- data.frame(CV=NA,BIC=NA,MODEL=NA,TOT_MISS=NA,PROP_MISS=NA,N=NA)
n_test <- list()
for (s in seq(from=20,to=50,by=10)){
  for (i in 1:2000){
test.set <- sample(1:nrow(tel.data),s)
res <-  mixmodLearn(tel.data[-test.set,], tel.class[-test.set], 
                  models=mixmodGaussianModel(listModels=listmod,equal.proportions=F),criterion= c("CV","BIC"))
   vec[i,1] <- res@bestResult@criterionValue[1]
   vec[i,2] <- res@bestResult@criterionValue[2]
   vec[i,3] <- res@bestResult@model
  
  
pred <-  mixmodPredict(tel.data[test.set,], classificationRule=res@bestResult)
   vec[i,4] <- sum(pred@partition == tel.class[test.set])
   vec[i,5] <- mean(pred@partition == tel.class[test.set])
  }
  cat(cat(paste("Progress",s,"\n")))
  vec$N <- rep(s,2000)
  n_test[[as.character(s)]]   <- vec 
}

tot <- bind_rows(n_test)

sort(rowSums(table(tot$MODEL,tot$N)),decreasing = T)

```




```{r}
fit <- stepFlexmix(Comp.1 ~ Comp.2 ,data=tel.comp.labels , k=2:4,verbose = TRUE, drop = F, unique = FALSE,FLXMRglm=(formula= .~. , family="gaussian"))

fit

```

